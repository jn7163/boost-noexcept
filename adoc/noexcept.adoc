:sourcedir: ..
:source-highlighter: pygments
= Noexcept
A generic error-handling library for C++11
:toc:
:toc-title:

== Abstract

Noexcept is designed to be used in environments where C++ exception handling is not permitted or unavailable. It follows the C++ exception handling semantics as much as possible without throwing exceptions. This preserves most of the useful programming techniques supported when exception handling is available:

* Errors are identified by static types rather than error codes, allowing classification of failures using a class hierarchy.
* Error-neutral contexts may communicate any type of error reported by lower level functions, even if that type is not defined in the current compilation unit.
* Error-handling contexts may selectively handle some errors but remain neutral to others.

== License

Distributed under the link:http://www.boost.org/LICENSE_1_0.txt[Boost Software License, Version 1.0].

NOTE: Noexcept is not part of Boost.

== Design rationale

When exception handling is unavailable, functions which may fail must communicate error conditions through their return value without interfering with its usual duties. This creates two competing design goals for Noexcept and other similar libraries:

. On one hand, ideally the library should have zero abstraction penalty and not allocate any dynamic memory.
. On the other hand, it must allow functions to return any value in case of success or failure, which normally would require a complex, feature-rich type-safe class template.

The idea behind Noexcept is to sidestep the second design goal altogether.

Noexcept does not require programmers to use a special class template in return values of functions that may fail. They can use any type whatsoever, the only requirement is that the return value semantics allow for an invalid state -- a special value that can be used to discriminate between success and failure.

When a failure is detected, an error object is created in thread-local storage. The presence of this object does not interfere with error-neutral functions or their return value types, except that they're required to communicate that _something_ went wrong. The error object is destroyed when control reaches an error-handling function which recognizes it by its type (yes, multiple active errors are supported, see <<faq,FAQ>>).

[[Introduction]]
== Crash course

[source,c++]
.Using Noexcept to handle `FILE` open errors
----
include::{sourcedir}/examples/FILE_ptr_example.cpp[]
----
<1> Partial specialization of `result_traits` for pointer types.
<2> The `throw_` moves the `file_open_error` object into static thread-local storage, and converts to `nullptr` for the return value (as specified in `result_traits`).
<3> The `try_` both checks for succcess and moves the return value of `open_file` into `tr`.
<4> The `catch_` returns a pointer to the error object (or `nullptr` if it can not be converted to `file_open_error`) and flags it as handled.
<5> When `tr` is destroyed the error object is destroyed if handled, otherwise left intact for another `try_`/`catch_` up the call stack to handle.

WARNING: If unhandled errors remain at the time the current thread terminates, Noexcept calls `abort()`. Use `catch_<>` to handle any error regardless of its type.

'''

[source,c++]
.Using Noexcept with `optional<>` and a C API
----
include::{sourcedir}/examples/c_api_example.cpp[]
----
<1> Partial specialization of `result_traits` for `boost::optional`.
<2> A simple C function which uses `int` status codes to indicate success or failure, and a `float` pointer to store the result.
<3> A simple error type to report failures from the C API function.
<4> The cumbersome `float` pointer interface of the `C` function is converted to `boost::optional<float>`. The `throw_` returns an empty `optional` in case of failure (as specified in `result_traits`).
<5> The `try_` both checks for succcess and moves the return value of `erratic_caller` into `tr`.
<6> The `catch_` returns a pointer to the error object (or `nullptr` if it can not be converted to `erratic_error`) and flags it as handled.

[[synopsis]]
== Synopsis

include::{sourcedir}/adoc/synopses/noexcept.hpp.adoc[]

include::{sourcedir}/adoc/synopses/result_traits.hpp.adoc[]

include::{sourcedir}/adoc/synopses/throw.hpp.adoc[]

include::{sourcedir}/adoc/synopses/try.hpp.adoc[]

include::{sourcedir}/adoc/synopses/result_traits_ptr.hpp.adoc[]

include::{sourcedir}/adoc/synopses/result_traits_optional.hpp.adoc[]

include::{sourcedir}/adoc/synopses/result_traits_std_optional.hpp.adoc[]

== Reference

=== `result_traits`

include::{sourcedir}/adoc/synopses/result_traits.hpp.adoc[]

`result_traits` is used to integrate user-defined result types into Noexcept. The main template is left undefined to prevent unwanted implicit conversions.

NOTE:  `result_traits` may be specialized for any value type, as long as its semantics define an "empty" state -- an invalid value that can be used to communicate that the function returning the result has failed.

User-defined (partial) specializations for a result type `R` should define the following members:

***

----
typedef <user-defined> value_type;
----
The type returned by `success_value()` (see below). For example, for `std::optional<T>` the `value_type` would be `T`.

***

----
static bool succeeded( R const & x ) noexcept;
----

_Returns:_::: `true` if `x` indicates success, `false` otherwise.

***

----
static R error_result() noexcept;
----
_Returns:_::: The special value of `R` which indicates failure (if this value is passed to `succeeded()` it must return `false`). For example, for `std::optional<T>`  `error_result` should return `std::optional<T>()`.

***

----
static value_type & success_value( result_type & x ) noexcept;
static value_type const & success_value( result_type const & x ) noexcept;
----
_Preconditions:_::: `succeeded(x)`.
_Returns:_::: The value of `x`.

***

----
template <class T>
bool succeeded_( T const & x )
----
This namespace-scope function template is provided for convenience. It is equivalent to `result_traits<T>::suceeded(x)`.

{blank} +

=== `throw_`

include::{sourcedir}/adoc/synopses/throw.hpp.adoc[]

`throw_` is a utility class designed to be used in `return` expressions to indicate failure:

----
return throw_(error());
----

The `error` object (of user-defined type) is moved to a special static thread-local storage, becoming the #current# error for its thread, where it remains until captured by a `try_`.

The `throw_` object itself implicitly converts to any type for which `result_traits` has been specialized; the `return` expression *always* effectively evaluates to `result_traits<R>::error_result()`, where `R` is the result type of the function.

***

----
throw_() noexcept;
----
_Effects:_:: None: the default constructor is used to continue propagating the #current# error.

***

----
template <class T>
throw_( T && e ) noexcept
----

_Preconditions:_:: For the calling thread there must be no #current# error not captured by a `try_`.
_Effects:_:: `e` becomes the #current# error for the calling thread.

***

----
template <class T>
operator T() noexcept;
----
_Preconditions:_:: For the calling thread there must be a #current# error, not captured by a `try_`.
_Returns:_:: `result_traits<T>::error_result()`.

{blank} +

=== `try_`

include::{sourcedir}/adoc/synopses/try.hpp.adoc[]
