:sourcedir: ..
:source-highlighter: pygments
= Noexcept

== Introduction

Noexcept is C+\+11 generic error handling library. It is designed to be used in environments where C++ exception handling is not permitted or unavailable.

Noexcept follows the C++ exception handling semantics as much as possible without throwing exceptions. This enables most of the useful programming techniques supported when exception handling is enabled:

* Errors are identified by static types rather than error codes, allowing classification of failures using a class hierarchy.
* Error-neutral contexts may communicate any type of error reported by lower level functions, even if that type is not defined in the current compilation unit.
* Error-handling contexts may selectively handle some errors but remain neutral to others.

== Design rationale

When exception handling is unavailable, functions which may fail must communicate error conditions through their return value without interfering with its usual duties. This creates two competing design goals for Noexcept and other similar libraries:

* On one hand, ideally the library should have zero abstraction penalty and not allocate any dynamic memory.
* On the other hand, it must allow functions to return any value in case of success or failure, which normally would require a complex, feature-rich type-safe class template.

The idea behind Noexcept is to sidestep the second design goal altogether.

Noexcept does not require programmers to use a special class template in return values of functions that may fail. They can use any type whatsoever, the only requirement is that the return value semantics allow for an invalid state, that is, a special value that can be used to discriminate between success and failure.

When a failure is detected, an error object is created in thread-local storage. The presence of this object does not interfere with error-neutral contexts, except that they're required to communicate that _something_ went wrong. The error object is destroyed when control reaches an error-handling function which recognizes it (by its type).

[[crash_course]]
== Crash course

=== Example: returning and handling file open errors 

This example takes advantage of the fact that C pointers comply with the 

[source,c++]
----
include::{sourcedir}/examples/FILE_ptr_example.cpp[]
----

[[synopsis]]
== Synopsis
[[result_traits.hpp]]
===== <boost/noexcept/result_traits.hpp>
NOTE: The main `result_traits` template is left undefined. User-defined specializations are required to define specific publicly accessible members. See <<result_traits,`result_traits`>> for details, <<result_traits_std_optional.hpp,`result_traits_std_optional`>> for an example.

include::synopses/result_traits.hpp.adoc[]

[[result_traits_ptr.hpp]]
===== <boost/noexcept/result_traits_ptr.hpp>
[source,c++]
----
namespace boost { namespace noexcept_ {

    template <class T>
    struct result_traits<T *> {
        typedef T * result_type;
        typedef T value_type;

        static bool succeeded( result_type x ) noexcept {
            return x!=0;
        }

        static result_type error_result() noexcept {
            return 0;
        }

        static value_type const & success_value( result_type x ) noexcept {
            return *x;
        }

        static value_type & success_value( result_type & x ) noexcept {
            return *x;
        }
    };

} }
----

[[result_traits_std_optional.hpp]]
===== <boost/noexcept/result_traits_std_optional.hpp>
[source,c++]
----
#include <optional>

namespace boost { namespace noexcept_ {

    template <class T>
    struct result_traits<std::optional<T> > {
        typedef std::optional<T> result_type;
        typedef T value_type;

        static bool succeeded( result_type const & x ) noexcept {
            return bool(x);
        }

        static result_type error_result() noexcept {
            return result_type();
        }

        static value_type const & success_value( result_type const & x ) noexcept {
            return x.value();
        }

        static value_type & success_value( result_type & x ) noexcept {
            return x.value();
        }
    };

} }
----

[[result_traits_boost_optional.hpp]]
===== <boost/noexcept/result_traits_boost_optional.hpp>
[source,c++]
----
namespace boost { template <class> class optional; }

namespace boost { namespace noexcept_ {

    template <class T>
    struct result_traits<std::optional<T> > {
        typedef optional<T> result_type;
        typedef T value_type;

        static bool succeeded( result_type const & x ) noexcept {
            return bool(x);
        }

        static result_type error_result() noexcept {
            return result_type();
        }

        static value_type const & success_value( result_type const & x ) noexcept {
            return x.value();
        }

        static value_type & success_value( result_type & x ) noexcept {
            return x.value();
        }
    };

} }
----

[[throw.hpp]]
===== <boost/noexcept/throw.hpp>
[source,c++]
----
namespace boost { namespace noexcept_ {

    class throw_ {
        throw_( throw_ const & )=delete;
        throw_ & operator=( throw_ const & )=delete;

    public:
 
        throw_();

        template <class T>
        throw_( T && e ) noexcept;

        template <class T>
        operator T() noexcept;
    };

} }
----

[[try.hpp]]
===== <boost/noexcept/try.hpp>
[source,c++]
----
namespace boost { namespace noexcept_ {

    template <class T>
    handler<T> try_( T && x );

    template <class T>
    class handler {

    public:

        handler( handler && ) noexcept;

		explicit operator bool() const noexcept;

        T const & operator()() const noexcept;
        T & operator()() noexcept;

        template <class E=void>
        E * catch_() noexcept;
    };
} }
----

== Documentation

[[result_traits]]
=== `result_traits`

`#include <boost/noexcept/result_traits.hpp>`

