:last-update-label!:
:sourcedir: ..
:source-highlighter: coderay
= Noexcept
A generic error-handling library for C++11
:toc: right
:toc-title:

== Abstract

Noexcept is designed to be used in environments where {CPP} exception handling is not permitted or unavailable. It follows the {CPP} exception handling semantics as closely as possible without throwing exceptions. This preserves most of the useful programming techniques supported when exception handling is available:

* Errors are identified by static types rather than error codes, allowing classification of failures using a class hierarchy;
* Function return values are not burdened with having to transport error objects in case of a failure;
* Error-neutral contexts may communicate any type of error reported by lower level functions, even if that type is not defined in the current compilation unit;
* Error-handling contexts may selectively handle some errors but remain neutral to others.

== License

Distributed under the link:http://www.boost.org/LICENSE_1_0.txt[Boost Software License, Version 1.0].

NOTE: Noexcept is not part of Boost.

== Design rationale

When exception handling is unavailable, functions which may fail must communicate error conditions through their return value without interfering with its usual duties. This creates two competing design goals for Noexcept and other similar libraries:

. On one hand, ideally the library should have zero abstraction penalty and not allocate any dynamic memory.
. On the other hand, it must allow functions to return any value in case of success or failure, which normally would require a complex, feature-rich type-safe class template.

The idea behind Noexcept is to sidestep the second design goal altogether.

Noexcept does not define a special return type -- programmers may use any type whatsoever, the only requirement is that the return value semantics allow for an invalid state -- a special value that can be returned in case of a failure.

When a failure is detected, an error object is created in thread-local storage. The presence of this object does not interfere with error-neutral functions or with their return values, except that they have to communicate that _something_ went wrong. The error object is destroyed when control reaches an error-handling function which recognizes it by its type (yes, multiple active errors are supported, see <<qanda,Q&A>>).

== Crash course

=== Using Noexcept to handle `FILE` open errors

[source,c++]
----
include::{sourcedir}/examples/FILE_ptr_example.cpp[tabsize=1]
----
<1> `<<throw_,throw_>>` associates the passed `file_open_error` object with the calling thread and converts to `0` for the return value (as specified by the `<<throw_,throw_return>>` template).
<2> `<<try_,try_>>` both checks for succcess and moves the return value of `open_file` into `tr`.
<3> `<<error_handler_catch_,catch_>>` returns a pointer to the error object (or `0` if it can not be converted to `file_open_error`) and flags it as handled.
<4> When `tr` is destroyed, the error object is destroyed if handled, otherwise left intact for another `try_`/`catch_` up the call stack to handle.

WARNING: If unhandled errors remain at the time the current thread terminates, Noexcept calls `abort()`. Use `catch_<>` to handle any error regardless of its type.

'''

=== Using Noexcept with link:http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html[`optional<>`] and a C API

[source,c++]
----
include::{sourcedir}/examples/c_api_example.cpp[]
----
<1> A C function which uses `int` status codes to indicate success or failure, and a `float` pointer to store the result.
<2> A simple error type to report failures from the C API function.
<3> The cumbersome `float` pointer interface of the `C` function is converted to `boost::optional<float>`. The `<<throw_,throw_>>` returns an empty `optional` in case of failure (as specified by the `<<throw_return,throw_return>>` template).
<4> `<<try_,try_>>` both checks for succcess and moves the return value of `erratic_caller` into `tr`.
<5> `<<error_handler_catch_,catch_>>` returns a pointer to the error object (or `0` if it can not be converted to `erratic_error`) and flags it as handled.

== Synopsis

include::{sourcedir}/adoc/synopses/noexcept.hpp.adoc[]

include::{sourcedir}/adoc/synopses/throw.hpp.adoc[]

include::{sourcedir}/adoc/synopses/error_handler.hpp.adoc[]

include::{sourcedir}/adoc/synopses/try.hpp.adoc[]

== Reference

[[throw_]]
=== `throw_`
[[throw_return]]

include::{sourcedir}/adoc/synopses/throw.hpp.adoc[]

`throw_` is a utility class designed to be used in `return` expressions to indicate failure:

[source,c++]
----
return throw_(my_error());
----
The passed `my_error` object becomes the current error for the calling thread. The error remains current until captured by an `<<error_handler,error_handler>>` (typically using `<<try_,try_>>`). For threads that have a current error, `<<has_current_error,has_current_error>>()` returns `true`.

The `throw_` object itself converts to any type so it can be used in `return` expressions in any function: if the function return type is `R`, the returned value is `throw_return<R>::value()`.

The `throw_return<R>` template may be specialized to specify the return value for user-defined types. The main template is defined such that:

* If `R` is not `bool` and `std::is_integral<R>::value` is true, then `throw_return<R>::value()` returns `static_cast<R>(-1)`.
* Otherwise the it returns `R()`.

The `throw_` class has the following members:

[source,c++]
----
template <class E>
throw_( E && e ) noexcept
----

_Preconditions:_:: `!<<has_current_error,has_current_error>>()`
_Effects:_:: `e` becomes the current error for the calling thread.
_Postconditions:_:: `has_current_error()`

***

[[throw_ctor]]
[source,c++]
----
throw_() noexcept;
----
_Effects:_:: None: the default constructor is used to continue propagating the current error.

***

[[throw_operator_R]]
[source,c++]
----
template <class R>
operator R() noexcept;
----
_Preconditions:_:: `<<has_current_error,has_current_error>>()`
_Returns:_:: `throw_return<R>::value()`.

***

[[has_current_error]]
[source,c++]
----
bool has_current_error() noexcept;
----
_Returns:_:: If `<<throw_,throw_>>` was used to set the current error for the calling thread, and if that error has not been captured by an `<<error_handler,error_handler>>` (or a `try_handler`, see `<<try_,try_>>`), `has_current_error` returns `true`. Otherwise it returns `false`.

{blank} +

[[error_handler]]
=== `error_handler`/`catch_`

include::{sourcedir}/adoc/synopses/error_handler.hpp.adoc[]

`error_handler` objects capture errors reported using `<<throw_,throw_>>`. This leaves the calling thread without a current error (`<<has_current_error,has_current_error>>()` is `false`).

Once the error is captured, use `<<error_handler_catch_,catch_>>` to handle specific errors (recognized by their type).

NOTE: The `error_handler` type may be used to handle errors, but it is more common to use the `<<try_handler,try_handler>>` type returned by `<<try_,try_>>()` instead.

The `error_handler` class has the following members:

[[error_handler_ctor]]
[source,c++]
----
error_handler() noexcept;
----
_Effects:_:: If `<<has_current_error,has_current_error>>()`, the current error for the calling thread is moved into `*this`.
_Postconditions:_:: `!has_current_error()`.

***
[[error_handler_dtor]]
[source,c++]
----
~error_handler() noexcept;
----
_Effects:_:: At the time `*this` is destroyed, if `<<error_handler_has_unhandled_error,has_unhandled_error>>()` is `true`, the error contained in `*this` becomes the current error of the calling thread again. Otherwise, if `<<error_handler_has_error,has_error>>()` is `true`, the captured error object is destroyed.

***

[[error_handler_has_error]]
[source,c++]
----
bool has_error() const noexcept;
----
_Returns:_:: `true` if `*this` contains an error object, `false` otherwise.

***

[[error_handler_has_unhandled_error]]
[source,c++]
----
bool has_unhandled_error() const noexcept;
----
_Returns:_:: `true` if `has_error()` and the error has not been handled, `false` otherwise.

NOTE: The error contained in an `error_handler` is marked as handled when `<<error_handler_catch_,catch_>><E>` is called, but only if it can be converted to type `E`.

***

[[error_handler_catch_]]
[source,c++]
----
template <class E=std::exception>
E * catch_() noexcept;
----
_Returns:_:: If `<<error_handler_has_error,has_error>>()` is `true`, returns `dynamic_cast<E *>(e)`, where `e` is an internal pointer to the error object captured into `*this`; otherwise returns `0`. The returned pointer becomes invalid if the `error_handler` object is moved or destroyed.
_Effects:_:: If the cast is successful, the error object captured into `*this` is marked as handled. See `<<error_handler_dtor,~error_handler>>()`.

NOTE: `catch_<>` (using the default for `E`) serves similar function to `catch(pass:[...])` when handling exceptions, however `catch_<>` is able to return a `std::exception` pointer because `throw_(my_error())` will inject `std::exception` as a base type if `my_error` doesn't derive from it.

***

[[error_handler_throw_exception]]
[source,c++]
----
void throw_exception();
----

_Effects:_:: If `<<error_handler_has_error,has_error>>()`, throws the error object as a {CPP} exception; otherwise no effect.

{blank} +

[[try_]]

=== `try_handler`/`try_`

[[try_handler]]

include::{sourcedir}/adoc/synopses/try.hpp.adoc[]

The `try_`  function template is used in contexts that handle errors reported (using `<<throw_,throw_>>`) by a lower level function: a return value of type `R` it is moved into the `try_handler<R>` object returned by `try_`.

Since `try_handler` derives from `error_handler`, all of the base type public functions are accessible. Unlike `error_handler` objects, `try_handler` objects define a public move constructor (so they can be returned by `try_`).

The `try_handler` class template has the following members:

[[try_handler_ctor]]
[source,c++]
----
explicit try_handler( R && res ) noexcept;
----
_Effects:_:: `res` is moved into `*this`. Also see `<<error_handler_ctor,error_handler>>()`.
_Postconditions:_:: `!<<has_current_error,has_current_error>>()`.

***

[source,c++]
----
explicit try_handler( try_handler && ) noexcept;
----
Public move constructor.

***

[[try_handler_operator_bool]]
[source,c++]
----
explicit operator bool() const noexcept;
----
_Returns:_:: Equivalent to `return !<<error_handler_has_error,has_error>>()`.

***

[[try_handler_result]]
[source,c++]
----
R const & result() const;
R & result();
----
_Effects:_:: If `!<<error_handler_has_error,has_error>>()`, `result()` returns a reference to the result object passed to `<<try_,try_>>` and moved into `*this`. Otherwise calling `result()` throws the error as a {CPP} exception.

***

[source,c++]
----
template <class R>
try_handler<R> try_( R && res ) noexcept;
----

This namespace-scope function is needed to deduce the `R` argument for the `try_handler` class template -- it simply returns `try_handler<R>(std::move(res))`. The following syntax is supported:

[source,c++]
----
if( auto tr=try_(f()) ) {
    //Success, use tr.result() to obtain the result from f()
} else {
    //Handle error, see try_handler::catch_<>
}
----

{empty} +

== Macros and configuration

----
BOOST_NOEXCEPT_ASSERT
----
All assertions in Noexcept use this macro; if not `#defined`, Noexcept header files `#define` it to link:http://www.boost.org/doc/libs/release/libs/assert/assert.html[`BOOST_ASSERT`].

***

----
BOOST_NOEXCEPT_USE_STD_THREAD_LOCAL
----
If `#defined`, Noexcept uses the {CPP} standard `thread_local` keyword for static thread-local storage, otherwise it uses link:http://www.boost.org/doc/libs/release/doc/html/thread/thread_local_storage.html[`boost::thread_specific_ptr`].

***

----
BOOST_NOEXCEPT_NO_THREADS
----
If `#defined`, Noexcept assumes that static storage is equivalent to thread-local storage.

***

----
BOOST_NOEXCEPT_THROW_EXCEPTION
----
All Noexcept functions are declared as `noexcept`, except for `<<try_handler_result,try_handler::result>>()` which throws exceptions using this macro. If not `#defined`, Noexcept header files `#define` it to link:http://www.boost.org/doc/libs/release/libs/exception/doc/BOOST_THROW_EXCEPTION.html[`BOOST_THROW_EXCEPTION`].

[[qanda]]
== Q&A

[qanda]
When using exception handling, there can be multiple active exception objects in each thread. Does Noexcept support multiple active errors?:: Yes, the current error object can be captured using `<<try_,try_>>`, at which point the calling thread is left without a current error.
+
However, it is up to the user to call `try_`: the code below is ill-formed, assuming that both function calls may fail -- that is, return using `<<throw_,throw_>>(my_error())`, for some user-defined type `my_error`:
+
 auto r1=f1();
 auto r2=f2();
+
The correct code would ensure that at the time `f2()` is called there is no current error for the calling thread. This could be done either by checking the return value of `f1()` (assuming `r1` converts to `bool` to indicate success or failure):
+
 if( auto r1=f1() ) {
     auto r2=f2(); //okay for f2 to fail (f1 didn't)
     ....
 } else {
     return throw_(); //let the caller deal with failures
 }
+
or by capturing `f1` failures using `try_`:
+
 auto r1=try_(f1()); //capture possible f1 failures
 auto r2=f2(); //okay, even if both f1 and f2 fail
+
(Nothrow asserts on `!<<has_current_error,has_current_error>>()` at the time an error object is passed to `<<thtrow_,throw_>>`).

Does this mean that I should always use `try_`?:: No, only use `try_` if you want to handle errors (see `<<error_handler_catch_,catch_>>`). In error-neutral contexts, in case of errors simply return `<<throw_,throw_>>()` without argument:
+
 if( auto r=f() ) {
     //Success -- use r
 } else {
     return throw_(); //Something went wrong
 }

What happens if `<<try_,try_>>` is called without any error being present?:: That is fine, in this case the value passed to `try_` will simply be moved into the returned `<<try_handler,try_handler>>` object, where it can be accessed using the `<<try_handler_result,result>>()` member function.

The design of Noexcept smells like exception handling to me, what about Overhead?:: It is true, Noexcept has been designed to mimic {CPP} exception handling in order to enable the same useful programming techniques it allows, perhaps most importantly freeing function return values from the burden of having to transport error objects.
+
While performance is an important design goal in Noexcept, consider that except when you use `<<try_,try_>>`, the speed of passing return values up the call stack is independent of Noexcept.

== Download

https://github.com/zajo/boost-noexcept

== Installation

Noexcept is a header-only library and requires no installation. The unit tests can be built with Boost Build: clone Noexcept under the `libs` directory in your Boost install, then `cd` into `libs/noexcept/test` and execute `b2` as usual.

{empty} +

[.small]#_(C) 2017 Emil Dotchevski_#
